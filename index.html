<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy NEW YEAR âœ¨</title>

    <link
        href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Poppins:wght@300;500;700&display=swap"
        rel="stylesheet">

    <style>
        /* Basic Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Full-page warm NEW YEAR gradient from wish.html */
        html,
        body {
            height: 100%;
            width: 100%;
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: radial-gradient(circle at 20% 10%, #2b0a00 0%, #12040a 60%, #0b0710 100%);
            overflow: hidden;
        }

        /* Canvas elements fill the viewport and are layered */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Z-index for layering effects */
        #starCanvas {
            z-index: -1;
        }

        #fireworksCanvas {
            z-index: 0;
        }

        #c {
            z-index: 1;
        }

        #petalsCanvas {
            z-index: 2;
            pointer-events: none;
        }

        /* Hearts container from index1.html */
        .hearts-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .heart {
            position: absolute;
            width: 30px;
            height: 30px;
            opacity: 0;
            transform: scale(0);
        }

        /* --- UPDATED CSS FOR WISH IMAGE CONTAINER --- */
        #wish-image-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            opacity: 0;
            display: none;

            /* --- YAHAN BADLAV KAREN --- */
            width: 90%;
            /* Screen ke 90% hisse tak failega */
            max-width: 650px;
            /*Lekin 650px se zyada bada nahi hoga */

            aspect-ratio: 16 / 9;
            /* Image ka aspect ratio maintain karega */
            border-radius: 10px;
            box-shadow: 0px 0px 50px 5px rgba(255, 47, 0, 0.5);
        }

        #wish-image {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Image ko container me fit karega, stretch nahi karega */
            border-radius: 10px;
        }

        #wish-message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 25px 25px;
            text-align: center;
            color: white;
            font-family: 'Dancing Script', cursive;

            /* --- YAHAN BHI BADLAV KAR SAKTE HAIN --- */
            /* Responsive font size: screen ke size ke hisab se adjust hoga */
            font-size: clamp(0.8em, 3vw, 1.5em);

            line-height: 1.5;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            opacity: 0;
        }

        /* Cursor for the typing text effect */
        #wish-message-overlay .gsap-cursor {
            font-size: 1em;
            color: rgb(255, 136, 0);
            opacity: 1;
            animation: blink 0.7s infinite;
        }

        p {
            margin: 0;
            position: absolute;
            left: 12px;
            bottom: 12px;
            color: #ffdca8;
            font-size: 14px;
            text-shadow: 0 1px 6px rgba(0, 0, 0, 0.6);
        }

        p a {
            color: #fff3d9;
            text-decoration: none;
            font-weight: 700;
        }

        p span {
            font-size: 12px;
            color: #ffdca8;
            opacity: 0.9;
            margin-left: 8px;
        }
    </style>
</head>

<body>
    <canvas id="starCanvas"></canvas>
    <canvas id="petalsCanvas"></canvas>
    <canvas id="fireworksCanvas"></canvas>

    <canvas id="c" aria-label="NEW YEAR animation"></canvas>

    <div class="hearts-container" id="heartsContainer"></div>

    <div id="wish-image-container">
        <img id="wish-image" src="image1.jpeg" alt="NEW YEAR Wish Image">
        <div id="wish-message-overlay"></div>
    </div>
    <p>
        <a href="#" target="_blank">Happy NEW YEAR âœ¨</a>
        <span>â€¢ Made by Sikindar</span>
    </p>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>

    <script>
        // ... (Pahla wala JavaScript code yahan waisa hi rahega) ...
        (function () {
            const canvas = document.getElementById('c');
            if (!canvas) throw new Error("Canvas element with id 'c' not found.");
            const ctx = canvas.getContext('2d');

            // --- YAHAN SE BADLAV SHURU ---
            // Screen ke size ke hisab se text ka size set karega
            const screenWidth = window.innerWidth;
            let charSettings;

            if (screenWidth < 768) { // Mobile devices ke liye settings
                charSettings = {
                    size: 24,
                    spacing: 32,
                    lineHeight: 40
                };
            } else { // Desktop/ à¤¬à¤¡à¤¼à¥‡ screen ke liye settings
                charSettings = {
                    size: 44,
                    spacing: 62,
                    lineHeight: 72
                };
            }
            // --- YAHAN TAK BADLAV KHATAM ---

            const opts = {
                strings: ["HAPPY", "NEW YEAR DEAR"],
                // Responsive values ka istemal
                charSize: charSettings.size,
                charSpacing: charSettings.spacing,
                lineHeight: charSettings.lineHeight,
                gravity: 0.12,
                upFlow: -0.06,
                fireworkPrevPoints: 12,
                fireworkBaseLineWidth: 6,
                fireworkAddedLineWidth: 8,
                fireworkSpawnTime: 140,
                fireworkBaseReachTime: 36,
                fireworkAddedReachTime: 40,
                fireworkCircleBaseSize: 22,
                fireworkCircleAddedSize: 14,
                fireworkCircleBaseTime: 36,
                fireworkCircleAddedTime: 26,
                fireworkCircleFadeBaseTime: 12,
                fireworkCircleFadeAddedTime: 8,
                fireworkBaseShards: 7,
                fireworkAddedShards: 8,
                fireworkShardPrevPoints: 3,
                fireworkShardBaseVel: 3.4,
                fireworkShardAddedVel: 2.6,
                fireworkShardBaseSize: 2,
                fireworkShardAddedSize: 3,
                letterContemplatingWaitTime: 260,
                balloonSpawnTime: 18,
                balloonBaseInflateTime: 12,
                balloonAddedInflateTime: 18,
                balloonBaseSize: 18,
                balloonAddedSize: 24,
                balloonBaseVel: 0.36,
                balloonAddedVel: 0.5,
                balloonBaseRadian: -(Math.PI / 2 - 0.4),
                balloonAddedRadian: -0.9
            };

            let DPR = Math.max(window.devicePixelRatio || 1, 1);
            let w = innerWidth,
                h = innerHeight,
                hw = w / 2,
                hh = h / 2;
            let calc = {
                totalWidth: 0
            };
            const Tau = Math.PI * 2;
            const letters = [];

            let animationHasFinished = false;

            function setSize() {
                DPR = Math.max(window.devicePixelRatio || 1, 1);
                const cssW = Math.max(1, innerWidth);
                const cssH = Math.max(1, innerHeight);
                canvas.style.width = cssW + 'px';
                canvas.style.height = cssH + 'px';
                canvas.width = Math.round(cssW * DPR);
                canvas.height = Math.round(cssH * DPR);

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(DPR, DPR);

                w = cssW;
                h = cssH;
                hw = w / 2;
                hh = h / 2;
                ctx.font = `${opts.charSize}px Verdana`;
                calc.totalWidth = opts.charSpacing * Math.max(...opts.strings.map(s => s.length));
            }

            function hueForX(x) {
                if (calc.totalWidth <= 0) return 40;
                const t = (x + calc.totalWidth / 2) / calc.totalWidth;
                return 30 + 25 * Math.min(Math.max(t, 0), 1);
            }

            function Letter(char, x, y) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.dx = -ctx.measureText(char).width / 2;
                this.dy = opts.charSize / 2;
                this.fireworkDy = this.y - hh;

                const hue = hueForX(x);
                this.hue = hue;
                this.color = `hsl(${hue},90%,50%)`;
                this.lightColor = (light) => `hsl(${hue},90%,${light}%)`;
                this.alphaColor = (alp) => `hsla(${hue},90%,52%,${alp})`;
                this.lightAlpha = (light, alp) => `hsla(${hue},90%,${light}%,${alp})`;

                this.reset();
            }

            Letter.prototype.reset = function () {
                this.phase = 'firework';
                this.tick = 0;
                this.spawned = false;
                this.spawningTime = Math.floor(opts.fireworkSpawnTime * Math.random());
                this.reachTime = Math.floor(opts.fireworkBaseReachTime + opts.fireworkAddedReachTime * Math.random());
                this.lineWidth = opts.fireworkBaseLineWidth + opts.fireworkAddedLineWidth * Math.random();
                this.prevPoints = [
                    [0, hh, 0]
                ];
            };

            Letter.prototype.step = function () {
                if (this.phase === 'firework') {
                    if (!this.spawned) {
                        ++this.tick;
                        if (this.tick >= this.spawningTime) {
                            this.tick = 0;
                            this.spawned = true;
                        }
                    } else {
                        ++this.tick;
                        const lp = this.tick / Math.max(1, this.reachTime);
                        const ap = Math.sin(lp * (Tau / 4));
                        const x = lp * this.x;
                        const y = hh + ap * this.fireworkDy;

                        if (this.prevPoints.length > opts.fireworkPrevPoints) this.prevPoints.shift();
                        this.prevPoints.push([x, y, lp * this.lineWidth]);

                        const lwp = 1 / Math.max(1, this.prevPoints.length - 1);
                        for (let i = 1; i < this.prevPoints.length; ++i) {
                            const p = this.prevPoints[i],
                                p2 = this.prevPoints[i - 1];
                            ctx.strokeStyle = this.alphaColor((i / this.prevPoints.length) * 0.9);
                            ctx.lineWidth = p[2] * lwp * i;
                            ctx.beginPath();
                            ctx.moveTo(p[0], p[1]);
                            ctx.lineTo(p2[0], p2[1]);
                            ctx.stroke();
                        }

                        if (this.tick >= this.reachTime) {
                            this.phase = 'contemplate';
                            this.circleFinalSize = opts.fireworkCircleBaseSize + opts.fireworkCircleAddedSize * Math.random();
                            this.circleCompleteTime = Math.floor(opts.fireworkCircleBaseTime + opts.fireworkCircleAddedTime * Math.random());
                            this.circleCreating = true;
                            this.circleFading = false;
                            this.circleFadeTime = Math.floor(opts.fireworkCircleFadeBaseTime + opts.fireworkCircleFadeAddedTime * Math.random());
                            this.tick = 0;
                            this.tick2 = 0;
                            this.shards = [];
                            const shardCount = Math.max(5, Math.floor(opts.fireworkBaseShards + opts.fireworkAddedShards * Math.random()));
                            const angle = (Tau / shardCount);
                            let cos = Math.cos(angle),
                                sin = Math.sin(angle);
                            let vx = 1,
                                vy = 0;
                            for (let i = 0; i < shardCount; ++i) {
                                const vx1 = vx;
                                vx = vx * cos - vy * sin;
                                vy = vx1 * sin + vy * cos;
                                this.shards.push(new Shard(this.x, this.y, vx, vy, this.alphaColor(1)));
                            }
                        }
                    }
                } else if (this.phase === 'contemplate') {
                    ++this.tick;
                    if (this.circleCreating) {
                        ++this.tick2;
                        const proportion = this.tick2 / Math.max(1, this.circleCompleteTime);
                        const armonic = -Math.cos(proportion * Math.PI) / 2 + 0.5;
                        ctx.beginPath();
                        ctx.fillStyle = this.lightAlpha(40 + 60 * proportion, proportion);
                        ctx.arc(this.x, this.y, armonic * this.circleFinalSize, 0, Tau);
                        ctx.fill();
                        if (this.tick2 > this.circleCompleteTime) {
                            this.tick2 = 0;
                            this.circleCreating = false;
                            this.circleFading = true;
                        }
                    } else if (this.circleFading) {
                        ctx.save();
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = 'rgba(255,200,110,0.9)';
                        ctx.fillStyle = this.lightColor(76);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        ctx.restore();

                        ++this.tick2;
                        const proportion = this.tick2 / Math.max(1, this.circleFadeTime);
                        const armonic = -Math.cos(proportion * Math.PI) / 2 + 0.5;
                        ctx.beginPath();
                        ctx.fillStyle = this.lightAlpha(100, 1 - armonic);
                        ctx.arc(this.x, this.y, this.circleFinalSize, 0, Tau);
                        ctx.fill();

                        if (this.tick2 >= this.circleFadeTime) this.circleFading = false;
                    } else {
                        ctx.save();
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'rgba(255,190,80,0.85)';
                        ctx.fillStyle = this.lightColor(72);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        ctx.restore();
                    }

                    for (let i = 0; i < this.shards.length; ++i) {
                        this.shards[i].step();
                        if (!this.shards[i].alive) {
                            this.shards.splice(i, 1);
                            --i;
                        }
                    }

                    if (this.tick > opts.letterContemplatingWaitTime) {
                        this.phase = 'balloon';
                        this.tick = 0;
                        this.spawning = true;
                        this.spawnTime = Math.floor(opts.balloonSpawnTime * Math.random());
                        this.inflating = false;
                        this.inflateTime = Math.floor(opts.balloonBaseInflateTime + opts.balloonAddedInflateTime * Math.random());
                        this.size = Math.floor(opts.balloonBaseSize + opts.balloonAddedSize * Math.random());
                        const rad = opts.balloonBaseRadian + opts.balloonAddedRadian * Math.random();
                        const vel = opts.balloonBaseVel + opts.balloonAddedVel * Math.random();
                        this.vx = Math.cos(rad) * vel;
                        this.vy = Math.sin(rad) * vel;
                        this.cx = this.x;
                        this.cy = this.y;
                    }
                } else if (this.phase === 'balloon') {
                    ctx.strokeStyle = this.lightColor(82);
                    ctx.lineWidth = 1.2;
                    if (this.spawning) {
                        ++this.tick;
                        ctx.fillStyle = this.lightColor(72);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        if (this.tick >= this.spawnTime) {
                            this.tick = 0;
                            this.spawning = false;
                            this.inflating = true;
                        }
                    } else if (this.inflating) {
                        ++this.tick;
                        const proportion = this.tick / Math.max(1, this.inflateTime);
                        const x = (this.cx = this.x);
                        const y = (this.cy = this.y - this.size * proportion);
                        ctx.fillStyle = this.alphaColor(proportion * 0.9);
                        ctx.beginPath();
                        generateBalloonPath(ctx, x, y, this.size * proportion);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, this.y);
                        ctx.stroke();
                        ctx.fillStyle = this.lightColor(70);
                        ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                        if (this.tick >= this.inflateTime) {
                            this.tick = 0;
                            this.inflating = false;
                        }
                    } else {
                        this.cx += this.vx;
                        this.cy += (this.vy += opts.upFlow);
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        generateBalloonPath(ctx, this.cx, this.cy, this.size);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(this.cx, this.cy);
                        ctx.lineTo(this.cx, this.cy + this.size);
                        ctx.stroke();
                        ctx.fillStyle = this.lightColor(76);
                        ctx.fillText(this.char, this.cx + this.dx, this.cy + this.dy + this.size);
                        if (this.cy + this.size < -hh - 120 || this.cx < -hw - 120 || this.cx > hw + 120) this.phase = 'done';
                    }
                }
            };

            function Shard(x, y, vx, vy, color) {
                const vel = opts.fireworkShardBaseVel + opts.fireworkShardAddedVel * Math.random();
                this.vx = vx * vel;
                this.vy = vy * vel;
                this.x = x;
                this.y = y;
                this.prevPoints = [
                    [x, y]
                ];
                this.color = color;
                this.alive = true;
                this.size = opts.fireworkShardBaseSize + opts.fireworkShardAddedSize * Math.random();
            }
            Shard.prototype.step = function () {
                this.x += this.vx;
                this.y += this.vy += opts.gravity;
                if (this.prevPoints.length > opts.fireworkShardPrevPoints) this.prevPoints.shift();
                this.prevPoints.push([this.x, this.y]);
                const lwp = this.size / Math.max(1, this.prevPoints.length);
                for (let k = 0; k < this.prevPoints.length - 1; ++k) {
                    const p = this.prevPoints[k],
                        p2 = this.prevPoints[k + 1];
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = (k + 1) * lwp * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(p[0], p[1]);
                    ctx.lineTo(p2[0], p2[1]);
                    ctx.stroke();
                }
                if (this.prevPoints[0][1] > hh + 60) this.alive = false;
            };

            function generateBalloonPath(ctx, x, y, size) {
                ctx.moveTo(x, y);
                ctx.bezierCurveTo(x - size / 2, y - size / 2, x - size / 4, y - size, x, y - size);
                ctx.bezierCurveTo(x + size / 4, y - size, x + size / 2, y - size / 2, x, y);
            }

            function createLetters() {
                letters.length = 0;
                const rows = opts.strings.length;
                const longest = Math.max(...opts.strings.map(s => s.length));
                calc.totalWidth = opts.charSpacing * longest;
                const blockHeight = opts.lineHeight * rows;
                for (let i = 0; i < rows; ++i) {
                    const str = opts.strings[i];
                    const rowWidth = opts.charSpacing * str.length;
                    const xOffset = -rowWidth / 2 + opts.charSpacing / 2;
                    const y = i * opts.lineHeight + opts.lineHeight / 2 - blockHeight / 2;
                    for (let j = 0; j < str.length; ++j) {
                        const x = xOffset + j * opts.charSpacing;
                        letters.push(new Letter(str[j], x, y));
                    }
                }
            }

            function animate() {
                window.requestAnimationFrame(animate);

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(hw, hh);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.font = `${opts.charSize}px Verdana`;

                let allDone = true;
                for (let i = 0; i < letters.length; ++i) {
                    letters[i].step();
                    if (letters[i].phase !== 'done') allDone = false;
                }

                ctx.restore();

                if (allDone && !animationHasFinished) {
                    animationHasFinished = true;
                    setTimeout(showWishImage, 1000); // Delay before showing image
                }
            }

            setSize();
            window.addEventListener('resize', () => {
                window.requestAnimationFrame(() => {
                    // NOTE: Resizing during animation can be complex,
                    // so we are not re-creating letters on resize for now.
                    // A full implementation would require re-calculating everything.
                    setSize();
                });
            }, {
                passive: true
            });

            createLetters();
            animate();
        })();

        // ... (Dusra wala JavaScript code yahan waisa hi rahega) ...
        const starCanvas = document.getElementById('starCanvas');
        const starCtx = starCanvas.getContext('2d');
        const fireworksCanvas = document.getElementById('fireworksCanvas');
        const fireworksCtx = fireworksCanvas.getContext('2d');
        const petalsCanvas = document.getElementById('petalsCanvas');
        const petalsCtx = petalsCanvas.getContext('2d');
        const heartsContainer = document.getElementById('heartsContainer');

        function resizeAllCanvases() {
            starCanvas.width = window.innerWidth;
            starCanvas.height = window.innerHeight;
            fireworksCanvas.width = window.innerWidth;
            fireworksCanvas.height = window.innerHeight;
            petalsCanvas.width = window.innerWidth;
            petalsCanvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeAllCanvases);
        resizeAllCanvases();

        class Star {
            constructor() { this.reset(); }
            reset() { this.x = Math.random() * starCanvas.width; this.y = Math.random() * starCanvas.height; this.size = Math.random() * 2 + 0.5; this.maxSize = this.size + Math.random() * 2; this.opacity = Math.random() * 0.5 + 0.3; this.glowFactor = Math.random() * 15 + 5; this.speed = Math.random() * 0.05 + 0.01; this.growing = Math.random() > 0.5; this.color = { r: 255, g: Math.floor(Math.random() * 100) + 155, b: Math.floor(Math.random() * 155) + 100 }; }
            update() { if (this.growing) { this.size += this.speed; if (this.size >= this.maxSize) this.growing = false; } else { this.size -= this.speed; if (this.size <= 0.5) this.growing = true; } if (Math.random() < 0.01) { this.color.g = Math.floor(Math.random() * 100) + 155; this.color.b = Math.floor(Math.random() * 155) + 100; } if (Math.random() < 0.001) this.reset(); }
            draw() { const glow = starCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * this.glowFactor); glow.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`); glow.addColorStop(1, 'rgba(255, 255, 255, 0)'); starCtx.fillStyle = glow; starCtx.beginPath(); starCtx.arc(this.x, this.y, this.size * this.glowFactor, 0, Math.PI * 2); starCtx.fill(); starCtx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`; starCtx.beginPath(); starCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); starCtx.fill(); }
        }

        class Petal {
            constructor() { this.reset(); }
            reset() { this.x = Math.random() * petalsCanvas.width; this.y = -20; this.size = Math.random() * 15 + 8; this.speedY = Math.random() * 1 + 0.5; this.speedX = Math.random() * 2 - 1; this.rotation = Math.random() * 360; this.rotationSpeed = Math.random() * 2 - 1; this.opacity = Math.random() * 0.5 + 0.5; this.color = { r: Math.floor(Math.random() * 55) + 200, g: Math.floor(Math.random() * 50), b: Math.floor(Math.random() * 80) + 50 }; }
            update() { this.y += this.speedY; this.x += Math.sin(this.y * 0.01) + this.speedX; this.rotation += this.rotationSpeed; if (this.y > petalsCanvas.height) this.reset(); }
            draw() { petalsCtx.save(); petalsCtx.translate(this.x, this.y); petalsCtx.rotate(this.rotation * Math.PI / 180); petalsCtx.beginPath(); petalsCtx.moveTo(0, 0); petalsCtx.bezierCurveTo(this.size / 2, -this.size / 4, this.size, -this.size / 2, 0, -this.size); petalsCtx.bezierCurveTo(-this.size, -this.size / 2, -this.size / 2, -this.size / 4, 0, 0); const gradient = petalsCtx.createLinearGradient(0, 0, 0, -this.size); gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`); gradient.addColorStop(1, `rgba(${this.color.r - 30}, ${this.color.g}, ${this.color.b + 20}, ${this.opacity * 0.7})`); petalsCtx.fillStyle = gradient; petalsCtx.fill(); petalsCtx.restore(); }
        }

        class FireworkParticle {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.radius = Math.random() * 3 + 1; this.velocity = { x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 }; this.gravity = 0.04; this.friction = 0.97; this.opacity = 1; this.life = Math.random() * 60 + 80; this.remainingLife = this.life; }
            update() { this.velocity.y += this.gravity; this.velocity.x *= this.friction; this.velocity.y *= this.friction; this.x += this.velocity.x; this.y += this.velocity.y; this.remainingLife--; this.opacity = this.remainingLife / this.life; }
            draw() { fireworksCtx.beginPath(); fireworksCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); fireworksCtx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`; fireworksCtx.fill(); const glow = fireworksCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 4); glow.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.7})`); glow.addColorStop(1, 'rgba(0, 0, 0, 0)'); fireworksCtx.fillStyle = glow; fireworksCtx.beginPath(); fireworksCtx.arc(this.x, this.y, this.radius * 4, 0, Math.PI * 2); fireworksCtx.fill(); }
        }

        class Firework {
            constructor(isHeart = false) { this.x = Math.random() * fireworksCanvas.width; this.y = fireworksCanvas.height; this.destination = { x: Math.random() * (fireworksCanvas.width * 0.8) + fireworksCanvas.width * 0.1, y: Math.random() * (fireworksCanvas.height * 0.5) + fireworksCanvas.height * 0.1 }; this.velocity = { x: (this.destination.x - this.x) / 100, y: (this.destination.y - this.y) / 100 }; this.particles = []; this.isHeart = isHeart; this.color = isHeart ? { r: Math.floor(Math.random() * 55) + 200, g: Math.floor(Math.random() * 50), b: Math.floor(Math.random() * 80) + 50 } : { r: Math.floor(Math.random() * 200) + 55, g: Math.floor(Math.random() * 200) + 55, b: Math.floor(Math.random() * 255) }; this.trail = []; this.exploded = false; }
            update() { if (!this.exploded) { this.x += this.velocity.x; this.y += this.velocity.y; this.trail.push({ x: this.x, y: this.y, opacity: 1 }); for (let i = 0; i < this.trail.length; i++) { this.trail[i].opacity -= 0.025; if (this.trail[i].opacity <= 0) this.trail.splice(i--, 1); } if (Math.hypot(this.destination.x - this.x, this.destination.y - this.y) < 10) this.explode(); } else { for (let i = 0; i < this.particles.length; i++) { this.particles[i].update(); if (this.particles[i].remainingLife <= 0) this.particles.splice(i--, 1); } } }
            explode() { this.exploded = true; if (this.isHeart) { const totalPoints = 150; for (let i = 0; i < totalPoints; i++) { const angle = (i / totalPoints) * Math.PI * 2; const heartX = 16 * Math.pow(Math.sin(angle), 3); const heartY = -(13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle)); const particle = new FireworkParticle(this.x, this.y, this.color); particle.velocity.x = heartX * (Math.random() * 0.1 + 0.05); particle.velocity.y = heartY * (Math.random() * 0.1 + 0.05); this.particles.push(particle); } } else { const particleCount = Math.floor(Math.random() * 50) + 80; for (let i = 0; i < particleCount; i++) this.particles.push(new FireworkParticle(this.x, this.y, this.color)); } }
            draw() { if (!this.exploded) { for (const t of this.trail) { fireworksCtx.beginPath(); fireworksCtx.arc(t.x, t.y, 2, 0, Math.PI * 2); fireworksCtx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${t.opacity})`; fireworksCtx.fill(); } } else { for (const p of this.particles) p.draw(); } }
        }

        const stars = Array.from({ length: 200 }, () => new Star());
        const petals = Array.from({ length: 50 }, () => new Petal());
        const fireworks = [];

        function addFirework() {
            fireworks.push(new Firework(Math.random() < 0.3));
        }

        function addFloatingHeart() {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.style.left = `${Math.random() * 90 + 5}%`;
            heart.style.top = `${Math.random() * 90 + 5}%`;
            heart.innerHTML = `<svg width="30" height="30" viewBox="0 0 24 24" fill="rgba(255, ${Math.random() * 100}, ${Math.random() * 100}, ${Math.random() * 0.4 + 0.6})" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
            heartsContainer.appendChild(heart);
            gsap.to(heart, {
                opacity: 1, scale: 1, duration: 0.5, ease: "elastic.out(1, 0.3)",
                onComplete: () => gsap.to(heart, { y: -150, x: (Math.random() - 0.5) * 100, opacity: 0, rotation: Math.random() * 60 - 30, scale: 0.5, duration: 4 + Math.random() * 4, ease: "power1.out", onComplete: () => heart.remove() })
            });
        }

        function animateStars() {
            starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
            stars.forEach(star => { star.update(); star.draw(); });
            requestAnimationFrame(animateStars);
        }

        function animatePetals() {
            petalsCtx.clearRect(0, 0, petalsCanvas.width, petalsCanvas.height);
            petals.forEach(petal => { petal.update(); petal.draw(); });
            requestAnimationFrame(animatePetals);
        }

        function animateFireworks() {
            fireworksCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            fireworksCtx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            for (let i = 0; i < fireworks.length; i++) {
                fireworks[i].update();
                fireworks[i].draw();
                if (fireworks[i].exploded && fireworks[i].particles.length === 0) fireworks.splice(i--, 1);
            }
            requestAnimationFrame(animateFireworks);
        }

        function showWishImage() {
            const wishImageContainer = document.getElementById('wish-image-container');
            const wishMessageOverlay = document.getElementById('wish-message-overlay');
            const wishImage = document.getElementById('wish-image');

            const messageText = "May this New Year light up not just your home, but your heart too â€” with peace, positivity, and new beginnings. âœ¨ Let every light remind you that even in the darkest moments, a single spark of hope can change everything. Wishing you and your loved ones endless happiness, good health, and countless moments of love and laughter. May your life shine brighter than every light around you. ðŸŒŸ Happy New Year â€” from my heart to yours. ðŸ’–";

            wishImage.onload = () => {
                gsap.set(wishImageContainer, { display: 'block' });
                gsap.to(wishImageContainer, {
                    opacity: 1,
                    duration: 2,
                    ease: 'power2.inOut',
                    onComplete: () => {
                        gsap.to(wishMessageOverlay, {
                            opacity: 1,
                            duration: 0.5,
                            onComplete: () => {
                                gsap.to(wishMessageOverlay, {
                                    duration: 4,
                                    text: {
                                        value: messageText,
                                        newClass: "gsap-cursor"
                                    },
                                    ease: 'none',
                                    delay: 0.5
                                });
                            }
                        });
                    }
                });
            };

            if (wishImage.complete && wishImage.naturalHeight !== 0) {
                wishImage.onload();
            } else if (wishImage.src) {
                // If src is set but not loaded, wait for the event
            } else {
                // If src is not even set, handle this case, maybe show an error
                console.error("Image src is not set!");
            }
        }


        window.addEventListener('load', () => {
            animateStars();
            animatePetals();
            animateFireworks();

            setInterval(addFirework, 800);
            setInterval(addFloatingHeart, 500);
        });
    </script>
</body>

</html>